version: "3.9"  

name: pulse-bridge

x-env: &app-env  
  ASPNETCORE_ENVIRONMENT: Development  

  # App settings (override via .env)
  ConnectionStrings__QuartzNet: ${DB_CONN}  
  ConnectionStrings__Redis: redis:${REDIS_PORT},password=${REDIS_PW} 

  # RabbitMQ settings consumed by Worker/Scheduler
  RabbitMq__Host: rabbitmq 
  RabbitMq__User: ${RABBITMQ_USER}
  RabbitMq__Pass: ${RABBITMQ_PASS}

networks:
  edge_net: { driver: bridge }  # Public edge for ingress/host access
  app_net: { driver: bridge, internal: true }  # Internal app-only network sql/redis/rabbitmq
  data_net: { driver: bridge, internal: true }  

services:
  traefik:
    image: traefik:v3.1  # Reverse proxy and router
    command:
      - --api.dashboard=true  # Enable built-in dashboard (internal)
      - --providers.docker=true  # Watch Docker for dynamic config
      #- --api.insecure=true  # Exposes dashboard without auth (avoid in prod)
      - --providers.docker.exposedbydefault=false  # Require explicit opt-in via labels
      - --entrypoints.web.address=:80  # HTTP entrypoint on port 80
      # For local HTTPS, uncomment and provide certs
      - --entrypoints.websecure.address=:443  # HTTPS entrypoint
      - --providers.file.filename=/etc/traefik/dynamic.yml
    ports:
      - "80:80"  # Expose HTTP from host to Traefik
      - "443:443"  # Expose HTTPS if configured
    volumes:
      - ./traefik/dynamic.yml:/etc/traefik/dynamic.yml:ro
      - ./traefik/certs:/certs:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro  # Read-only access to Docker events
    networks: [edge_net, app_net]  # Reach host and internal services
    healthcheck:
      test: ["CMD", "traefik", "healthcheck"]  # Liveness probe
      interval: 10s  # How often to check
      timeout: 5s  # Max time per check
      retries: 5  # Fail after N attempts

  web:
    image: pulse-bridge-web:1.0  
    container_name: pulse-bridge-web  
    labels:
      - traefik.enable=true  # Opt-in to Traefik routing
      #- traefik.http.routers.web.rule=Host(`ui.localtest.me`)  # Route by host
      - traefik.http.routers.websecure.rule=Host(`ui.localtest.me`)  # Route by host
      #- traefik.http.routers.web.entrypoints=web  # Listen on HTTP
      - traefik.http.routers.websecure.entrypoints=websecure
      - traefik.http.routers.websecure.tls=true  # Enable TLS
      - traefik.http.routers.websecure.middlewares=gzip@file,secure-headers@file
      - traefik.http.services.web.loadbalancer.server.port=80  # Container port
    networks: [app_net]  # Only needs internal app net
    depends_on: [traefik]  # Ensure proxy ready before start
    restart: unless-stopped  # Auto-restart for resilience

  api:
    image: pulse-bridge-api:1.0  
    container_name: pulse-bridge-api  
    environment:
      <<: *app-env  # Merge common .NET env
      ASPNETCORE_URLS: http://+:8080  # DB for Quartz.NET

    labels:
      - traefik.enable=true  # Opt-in to Traefik routing
      - traefik.http.routers.api.rule=Host(`api.localtest.me`)  # Route by host
      #- traefik.http.routers.api.entrypoints=web  # Listen on HTTP
      - traefik.http.routers.api.entrypoints=websecure
      - traefik.http.routers.api.tls=true  # Enable TLS
      - traefik.http.routers.api.middlewares=gzip@file,secure-headers
      - traefik.http.services.api.loadbalancer.server.port=8080  # Container port
      
      # --- CORS middleware (for UI -> API) ---
      - traefik.http.routers.api.middlewares=api-cors@docker  # Attach CORS middleware
      - traefik.http.middlewares.api-cors.headers.accesscontrolalloworiginlist=https://ui.localtest.me  # Allowed origin
      # Methods needed by SignalR (negotiate = POST; ws upgrade = GET; and preflight = OPTIONS)
      - traefik.http.middlewares.api-cors.headers.accesscontrolallowmethods=GET,POST,OPTIONS  # Allow needed methods
      # Headers SignalR typically sends (include Authorization if you use JWT)
      - traefik.http.middlewares.api-cors.headers.accesscontrolallowheaders=Authorization,Content-Type,X-Requested-With,X-SignalR-User-Agent  # Allow headers SignalR/JWT use
      # If you prefer, you can allow all headers instead of listing:
      # - traefik.http.middlewares.api-cors.headers.accesscontrolallowheaders=*
      - traefik.http.middlewares.api-cors.headers.accesscontrolallowcredentials=true  # Allow cookies/credentials
      # Optional niceties:
      - traefik.http.middlewares.api-cors.headers.addvaryheader=true  # Proper caching of CORS responses
      - traefik.http.middlewares.api-cors.headers.accesscontrolmaxage=86400  # Cache preflight for a day
    networks: [app_net, data_net]  # Internal only; fronted by Traefik
    restart: unless-stopped  # Auto-restart for resilience

  worker:
    image: pulse-bridge-worker:1.0 
    container_name: pulse-bridge-worker  
    environment: 
      <<: *app-env  # Reuse common .NET env
      App__SendAndReceiveUrl: http://api:8080/api/external/send  # SignalR endpoint
    depends_on:
      - rabbitmq  # Needs broker to connect
      - api  # Talks to API/SignalR
      - redis  # Uses Redis for caching
    networks: [app_net, data_net]  # Access app and data tiers
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:8080/"]  # Probe HTTP endpoint
      interval: 10s
      timeout: 5s
      retries: 10

  scheduler:
    image: pulse-bridge-scheduler:1.0  
    container_name: pulse-bridge-scheduler 
    environment:
      <<: *app-env  # Merge common env
      Quartz__JobStore: AdoNet  # Persist jobs in DB
      ConnectionStrings__QuartzNet: ${DB_CONN}  # DB for Quartz.NET
      App__IntervalInSeconds: 5  # Worker polling interval
    depends_on:
      - sql  # Requires DB first
      - rabbitmq  # Publishes/consumes via broker
    networks: [app_net, data_net]  # Needs app/data access
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:8080/"]  # Probe HTTP endpoint
      interval: 10s
      timeout: 5s
      retries: 10

  sql:
    image: mcr.microsoft.com/mssql/server:2022-latest  # SQL Server 2022 image
    container_name: pulse-bridge-sql  # Stable name
    environment:
      ACCEPT_EULA: "Y"  # Required to run MSSQL
      SA_PASSWORD: ${SA_PASSWORD}  # SA password from .env
      MSSQL_PID: "Developer"  # Free dev edition
    networks: 
      - data_net  # Internal data tier only
      #- edge_net  # Allow host access for management (dev only)
    #ports:
      #- "1433:1433"     # Allow host access for management (dev only)
    volumes:
      - mssqldata:/var/opt/mssql  
    restart: unless-stopped  

  redis:
    image: redis:7.2  
    command: ["redis-server", "--appendonly", "yes","--requirepass","${REDIS_PW}"]  # Enable AOF persistence
    container_name: pulse-bridge-redis  
    networks: [data_net]  # Internal data tier only
    #ports:
      #- "6379:6379"   # Expose only if needed for external access
    volumes:
      - redisdata:/data  
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PW}", "ping"]  # Liveness probe
      interval: 10s
      timeout: 5s
      retries: 10
    security_opt: ["no-new-privileges:true"]  # Drop root privileges for security
    restart: unless-stopped 

  rabbitmq:
    image: rabbitmq:3.13-management  # Broker with management UI
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER} 
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASS}  
    networks: [data_net]  # Internal data tier only
    #ports:
      #- "15672:15672" # Mgmt UI; expose only in dev
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq  
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "-q", "ping"]  # Liveness probe
      interval: 10s
      timeout: 5s
      retries: 10
    security_opt: ["no-new-privileges:true"]  # Drop root privileges for security
    restart: unless-stopped  

# Persist state so host reboots don't lose data
volumes:
  mssqldata:  
  redisdata:  
  rabbitmq_data:  
